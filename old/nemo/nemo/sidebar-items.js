initSidebarItems({"fn":[["channel",""],["channel_dual",""]],"macro":[["handlers!",""],["proto!",""]],"mod":[["channels","Channels are implementations of `IO` which can be used when building `Session` and designing protocols."],["peano","Peano numbers are natural numbers expressed as successions of zero. We use them in our API to provide \"nested\" protocol escaping, as you must indicate the number of layers you wish to escape from."],["session_types","Session types encode the current state of a communication channel. It is not possible to change to another state without following the protocol."]],"struct":[["Channel","Channels are provided to handlers to act as a \"courier\" for the session type and a guard for the IO backend."],["Defer","Handlers must return `Defer` to indicate to the `Session` how to proceed in the future. `Defer` can be obtained by calling `.defer()` on the channel, or by calling `.close()` when the session is `End`."]],"trait":[["Handler","`Handler` is implemented on `Protocol` for every session type you expect to defer, including the initial state."],["IO","This trait is implemented by backing IO structures to offer an interface for bi-directional channels. Discriminants are sent and received by `Channel` to indicate protocol changes; they tend to be smaller numbers, and so a variable length integer could be sent over a network instead of the raw `usize`."],["Protocol","A `Protocol` describes the underlying protocol, including the \"initial\" session type. `Handler`s are defined over concrete `Protocol`s to implement the behavior of a protocol in a given `SessionType`."],["Transfers","An implementation of this trait provides sending and receiving functionality to `Channel` for an arbitrary `T`. `Channel` will only ever call these functions if it expects a `T`, so long as outside of this trait and `IO` the backing channel cannot be accessed."]]});